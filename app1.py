import streamlit as st
import pandas as pd
import plotly.express as px
import gdown
from io import BytesIO
import requests

st.set_page_config(page_title="Indicadores de dasos", layout="wide")

st.title("üìä Indicadores de casos")

# Configura√ß√£o do Google Drive
@st.cache_data(ttl=300)  # Cache por 5 minutos
def load_data():
    # URL do seu arquivo (modificada para o formato de download direto)
    file_id = "1SqSOc1xsb1i9hxq2OziyxWHrG3GAs450"
    url = f"https://drive.google.com/uc?id={file_id}"
    
    try:
        # Usando gdown para baixar o arquivo
        output = 'temp_file.xlsx'
        gdown.download(url, output, quiet=True)
        
        df = pd.read_excel(output, parse_dates=["Abertura", "Solu√ß√£o"])
        
        # Processamento dos dados (igual ao seu c√≥digo original)
        df["AnoMes"] = df["Abertura"].dt.strftime('%Y-%m')
        df["AnoMes_Display"] = df["Abertura"].dt.strftime('%b/%Y')
        df["Ano"] = df["Abertura"].dt.year
        df["Conta_Resumida"] = df["Conta"].apply(lambda x: ' '.join(x.split()[:2]) if pd.notnull(x) else x)
        
        return df
    except Exception as e:
        st.error(f"Erro ao carregar dados: {e}")
        return None

# Bot√£o de refresh
if st.button("üîÑ Atualizar Dados"):
    st.cache_data.clear()

# Carrega os dados
df = load_data()

if df is not None:
    # Filtros (igual ao seu c√≥digo original)
    anos = sorted(df["Ano"].dropna().astype(int).unique())
    origens = sorted(df["Origem"].dropna().unique())
    responsaveis = sorted(df["Respons√°vel"].dropna().unique())

    st.sidebar.header("üîç Filtros")

    ano_sel = st.sidebar.multiselect("Ano:", anos, default=anos)
    origem_sel = st.sidebar.multiselect("Origem:", origens, default=origens)
    resp_sel = st.sidebar.multiselect("Respons√°vel:", responsaveis, default=responsaveis)

    # Aplicar filtros
    df_filtrado = df[
        df["Ano"].isin(ano_sel) &
        df["Origem"].isin(origem_sel) &
        df["Respons√°vel"].isin(resp_sel)
    ]

    if df_filtrado.empty:
        st.warning("‚ö†Ô∏è Nenhum dado para os filtros selecionados.")
    else:
        # Criar ordena√ß√£o cronol√≥gica
        df_ordenado = df_filtrado.sort_values("AnoMes")
        meses_ordenados = df_ordenado["AnoMes"].unique()
        meses_display_ordenados = df_ordenado["AnoMes_Display"].unique()

        ## 1Ô∏è‚É£ Total de Casos por M√™s
        st.subheader("1Ô∏è‚É£ Total de casos por m√™s")
        casos_mes = df_filtrado.groupby(["AnoMes", "AnoMes_Display"]).size().reset_index(name="Total")
        casos_mes = casos_mes.sort_values("AnoMes")

        fig1 = px.bar(
            casos_mes, 
            x="AnoMes_Display", 
            y="Total", 
            text="Total", 
            title="Total de Casos por M√™s"
        )
        fig1.update_traces(textposition='outside')
        fig1.update_xaxes(
            type='category', 
            categoryorder='array', 
            categoryarray=meses_display_ordenados,
            title_text="M√™s/Ano"
        )
        st.plotly_chart(fig1, use_container_width=True)

        ## 2Ô∏è‚É£ Casos por Origem (Mensal) - Barras lado a lado
        st.subheader("2Ô∏è‚É£ Casos por origem (Mensal)")
        casos_origem = df_filtrado.groupby(["AnoMes", "AnoMes_Display", "Origem"]).size().reset_index(name="Total")
        casos_origem = casos_origem.sort_values("AnoMes")

        fig2 = px.bar(
            casos_origem, 
            x="AnoMes_Display", 
            y="Total", 
            color="Origem", 
            text="Total", 
            title="Casos por Origem",
            barmode='group'
        )
        fig2.update_traces(textposition='outside')
        fig2.update_xaxes(
            type='category', 
            categoryorder='array', 
            categoryarray=meses_display_ordenados,
            title_text="M√™s/Ano"
        )
        st.plotly_chart(fig2, use_container_width=True)

        ## 3Ô∏è‚É£ Reaberturas por M√™s - Agora com barras
        st.subheader("3Ô∏è‚É£ Reaberturas por m√™s")
        reaberturas = df_filtrado.groupby(["AnoMes", "AnoMes_Display"])["Qt Reab."].sum().reset_index()
        reaberturas = reaberturas.sort_values("AnoMes")

        fig3 = px.bar(
            reaberturas, 
            x="AnoMes_Display", 
            y="Qt Reab.", 
            text="Qt Reab.", 
            title="Reaberturas por m√™s"
        )
        fig3.update_traces(textposition='outside')
        fig3.update_xaxes(
            type='category', 
            categoryorder='array', 
            categoryarray=meses_display_ordenados,
            title_text="M√™s/Ano"
        )
        st.plotly_chart(fig3, use_container_width=True)

        ## 4Ô∏è‚É£ Top 10 Contas com Mais Casos - Nomes resumidos
        st.subheader("4Ô∏è‚É£ Top 10 contas com mais casos")
        top_contas = df_filtrado["Conta_Resumida"].value_counts().nlargest(10).reset_index()
        top_contas.columns = ["Conta", "Total"]

        fig4 = px.bar(
            top_contas, 
            x="Conta", 
            y="Total", 
            text="Total", 
            title="Top 10 contas"
        )
        fig4.update_traces(textposition='outside')
        fig4.update_layout(xaxis={'categoryorder':'total descending'})
        st.plotly_chart(fig4, use_container_width=True)

        ## 5Ô∏è‚É£ Casos por Respons√°vel (Mensal)
        st.subheader("5Ô∏è‚É£ Casos por respons√°vel (Mensal)")
        
        df_filtrado = df_filtrado.copy()
        df_filtrado["Primeiro_Nome"] = df_filtrado["Respons√°vel"].str.split().str[0].fillna("N√£o informado")

        casos_resp = (df_filtrado.groupby(["AnoMes", "AnoMes_Display", "Primeiro_Nome"])
                    .size()
                    .reset_index(name="Total"))

        casos_resp = casos_resp.sort_values(["AnoMes", "Total"], ascending=[True, False])

        fig5 = px.bar(
            casos_resp,
            x="Primeiro_Nome",
            y="Total",
            color="Primeiro_Nome",
            text="Total",
            title="Casos por respons√°vel",
            facet_col="AnoMes_Display",
            category_orders={"Primeiro_Nome": casos_resp["Primeiro_Nome"].tolist()}
        )

        fig5.update_traces(
            textposition='outside',
            textangle=0,
            marker_line_width=0.5
        )

        fig5.update_layout(
            xaxis_title=None,
            yaxis_title="Total de casos",
            showlegend=False
        )

        fig5.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1]))
        fig5.update_xaxes(title_text=None)

        st.plotly_chart(fig5, use_container_width=True)

        ## 6Ô∏è‚É£ √çndice de Resolubilidade
        st.subheader("6Ô∏è‚É£ √çndice de Resolubilidade")

        import calendar
        import plotly.graph_objects as go

        df_filtrado["Resolvido_Mesmo_Dia"] = df_filtrado["Abertura"] == df_filtrado["Solu√ß√£o"]
        df_filtrado["Ano"] = df_filtrado["Abertura"].dt.year
        df_filtrado["Mes"] = df_filtrado["Abertura"].dt.month
        df_filtrado["Mes_Display"] = df_filtrado["Mes"].apply(lambda x: calendar.month_abbr[x]) + "/" + df_filtrado["Ano"].astype(str)
        df_filtrado["Mes_Ano_Ordenacao"] = df_filtrado["Ano"] * 100 + df_filtrado["Mes"]
        df_filtrado["Primeiro_Nome"] = df_filtrado["Respons√°vel"].str.split().str[0].fillna("N√£o informado")

        meses_ordenados = (
            df_filtrado[["Mes_Display", "Mes_Ano_Ordenacao"]]
            .drop_duplicates()
            .sort_values("Mes_Ano_Ordenacao")
        )

        meses_disponiveis = meses_ordenados["Mes_Display"].tolist()
        mes_escolhido = st.selectbox("Selecione o m√™s:", meses_disponiveis, index=len(meses_disponiveis)-1)

        df_mes = df_filtrado[df_filtrado["Mes_Display"] == mes_escolhido]

        total_casos = (df_mes
                    .groupby("Primeiro_Nome")
                    .size()
                    .reset_index(name="Total_Casos"))

        resolvidos_mesmo_dia = (df_mes[df_mes["Resolvido_Mesmo_Dia"]]
                                .groupby("Primeiro_Nome")
                                .size()
                                .reset_index(name="Resolvidos_Mesmo_Dia"))

        resumo = pd.merge(total_casos, resolvidos_mesmo_dia,
                        on="Primeiro_Nome", how="left").fillna(0)

        resumo["%_Resolubilidade"] = (resumo["Resolvidos_Mesmo_Dia"] / resumo["Total_Casos"]) * 100

        fig = go.Figure()

        x_labels = resumo["Primeiro_Nome"]

        fig.add_trace(go.Bar(
            x=x_labels,
            y=resumo["Total_Casos"],
            name="Total de casos",
            text=resumo["Total_Casos"],
            textposition="auto"
        ))

        fig.add_trace(go.Bar(
            x=x_labels,
            y=resumo["Resolvidos_Mesmo_Dia"],
            name="Resolvidos no mesmo dia",
            text=resumo["Resolvidos_Mesmo_Dia"],
            textposition="auto"
        ))

        fig.add_trace(go.Scatter(
            x=x_labels,
            y=resumo["%_Resolubilidade"],
            name="% Resolubilidade",
            mode="lines+markers+text",
            text=[f"{v:.1f}%" for v in resumo["%_Resolubilidade"]],
            textposition="top center",
            yaxis="y2"
        ))

        fig.update_layout(
            title=f"√çndice de resolubilidade - {mes_escolhido}",
            xaxis_title="Respons√°vel",
            yaxis=dict(title="Quantidade de casos"),
            yaxis2=dict(title="% Resolubilidade", overlaying="y", side="right"),
            barmode="group",
            legend=dict(title="Legenda", x=1.05, y=1),
            margin=dict(r=100)
        )

        st.plotly_chart(fig, use_container_width=True)

        st.success(f"‚úÖ Dashboard atualizado em {pd.Timestamp.now().strftime('%H:%M:%S')}")
else:
    st.error("N√£o foi poss√≠vel carregar os dados. Verifique a conex√£o ou tente novamente mais tarde.")